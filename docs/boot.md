# Bootloader

The EZRadioPRO enters the bootloader when powered on or after exiting shutdown (`SDN` pin transitioning from high to low). The bootloader is exited on completion of the `POWER_UP` command.

Table of Contents
* [Boot process](#boot-process)
* [SPI API](#spi-api)
* [Patch process](#patch-process)
* [Patch encryption](#patch-encryption)
* [Memory organization](#memory-organization)
* [Open RE topics](#open-re-topics)

## Boot process

The boot process is as follows:
* enable NVM and basic clocks, incl. NVM timing calibration
* check flag `SPI_STATUS:WARM_BOOT`, execute following steps if flag is clear:
  * set flag `SPI_STATUS:WARM_BOOT`
  * copy part information from `NVM:0x5510` to `RAM:0x07f0`
  * copy calibration data from `NVM:0x5578` to `RAM:0x0761`
  * copy ACFG defaults from `NVM:0x5520` to `RAM:0x0798`
  * run boot script located at `NVM:0x5600` 
* Start `TIMER0` (timeout?)
* Enable SPI command interrupt (`0x1F` `INT_COMMAND`), enabling SPI API
* Wait until a valid `FUNC` image was loaded, likely via `POWER_UP` command
* Stop SPI API
* Reset radio peripherals and start main crystal
* Stop `TIMER0` and exit bootloader

It's unknown what `WARM_BOOT` refers to. Maybe this flag is preserved when resetting the via `SDN` pin.

The boot script run from NVM is a list of SPI API commands, similar to the radio config file generated by WDS. The script is empty in all parts analyzed so far.

## SPI API

Only a subset of the officially documented SPI API commands are available in the bootloader. Some commands are more limited in boot mode than after `POWER_UP`, for example `FUNC_INFO` will only return `ROM_ID` while in boot mode.

All SPI API commands are processed during the SPI command interrupt.

The bootloader implements several undocumented commands for factory testing and patching firmware.

`PEEK` and `POKE` are not available at this stage.

For full list of available commands see [api-cmd.md](api-cmd.md).

## Patch process

Firmware patches write code to RAM and update interrupt vectors and jump tables to invoke that code. Firmware patches are not persisted over power cycles, and probably also lost when entering shutdown.

Similar to the radio config files generated by WDS, firmware patches are a sequence of SPI API commands. All patch commands are 8 bytes long.

A patch starts with the command `PATCH_IMAGE` (`0x04`). Arguments of the command are:
* ID of `FUNC` image to load before patching (optional)
* 16 bit CRC (optional) for the RAM after the patch is complete
* Two 8 bit keys `KEY1` and `KEY2` for decryption of subsequent patch commands

The remainder of the patch are a series of `PATCH_COPY` and `PATCH_ARGS`/`PATCH_DATA` commands.

`PATCH_COPY` (`0x06`) copies data from NVM or ROM into RAM. Command arguments are source address, destination address and number of bytes to copy. The command field includes the LSB of the current CRC (`CMD[3]`), making `PATCH_COPY2` (`0x0A`) an alias.

`PATCH_ARGS` (`0x05`) and `PATCH_DATA` (`0xE_`) are used to upload data to RAM through the SPI API. Argument of the `PATCH_ARGS` command are:
* `PIP` flag to indicate if the patch continues (1) or if this is last command of the patch (0)
* Destination address for subsequent `PATCH_DATA` commands
* 16 bit CRC of the patch so far (including the current command).

Except for the very end of a patch, `PATCH_ARGS` is followed by one or more `PATCH_DATA` commands with the data to be stored in RAM. The `CMD` argument of `PATCH_DATA` is `0xE0` combined with number of valid bytes in the payload (`CMD[2:0]`) and the LSB of the current CRC (`CMD[3]`).

Except for `PATCH_IMAGE`, all patch commands are encrypted with an XOR scheme, verified by a CRC. 

Address fields use the address mapping of the Memory Controller (`MEMCTL`). This means that RAM is located from `0x4000` to `0x47FF`.

## Patch encryption

Some patch commands are partially encrypted:
* `PATCH_COPY`: Arguments `0x01` - `0x07`
* `PATCH_ARGS`: Arguments `0x01` - `0x05`
* `PATCH_DATA`: Arguments `0x01` - `0x07`

[This Python script](../tools/README.md#patch-cryptopy) reimplements the decryption logic of the bootloader.

The encryption scheme has four parts:
* Two 8 bit keys provided with the patch (`PATCH_IMAGE` `KEY1` and `KEY2`)
* `ROM_ID` of the target device (stored in ROM at `0xFFFE`)
* Content of ROM of the target device (`0x8000` to `0x88FF`)
* 32/16 bit CRC

`KEY1` and `KEY2` are XORed with `ROM_ID` and ROM content to initialize CRC and other variables.

Decryption is done per byte. The encrypted byte is XORed with bytes from ROM with addresses determined by the keys and previous data.

A 32 bit CRC is continously updated, with the first 16 bit being used for verification.

The command `RAM_TEST` (`0x03`) seems to use a different algorithm to calculate the checksum (CRC) of a given memory area.

## Memory organization

The bootloader is located in ROM from `0x8000` to `0x876F`, including reset vector (`0x8000`) and the interrupt vector to process SPI commands (`0x801F` `INT_COMMAND`).

In boot mode, the bootloader portion of ROM is mapped to `0x0000`, overlaying RAM. It is very likely that this is controlled by `SPI_STATUS:SPI_LLRAM_OVERLAY` which is set to 1 just before exiting bootloader.

## Open RE topics

* Implement encryption and CRC required to issue patch commands
* How to verify the overlay theory after `POWER_UP`?
  * If clearing `SPI_STATUS:SPI_LLRAM_OVERLAY` overlays RAM with the bootloader, the IC will likely crash without graceful hand-off to bootloader
* How to dump memory during `POWER_UP`?
  * Use `PATCH_DATA` to reconfigure SPI DMA and use `READ_RX_FIFO`?
  * Use `PATCH_COPY` to copy arbritrary memory into SPI API reply stream?
